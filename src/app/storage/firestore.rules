rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() { return request.auth != null; }
    function isOwner(uid) { return isSignedIn() && uid == request.auth.uid; }
    function isOwnerOnExisting() { return isSignedIn() && resource.data.ownerUid == request.auth.uid; }

    // Per-user root doc (profile / preferences)
    match /users/{uid} {
      allow read: if isOwner(uid);
      // On create, enforce ownership stamp
      allow create: if isSignedIn() && request.resource.data.ownerUid == request.auth.uid;
      allow update, delete: if isOwnerOnExisting();
    }

    // Sessions nested under a user: users/{uid}/sessions/{sessionId}
    match /users/{uid}/sessions/{sessionId} {
      allow read: if isOwner(uid);
      allow create: if isOwner(uid)
        && request.resource.data.ownerUid == request.auth.uid
        && request.resource.data.date is timestamp
        && request.resource.data.practiceTime is int
        && request.resource.data.practiceTime >= 0;
      allow update, delete: if isOwnerOnExisting();
    }

    // Global songs catalog (read-only for regular users)
    match /songs/{songId} {
      allow read: if true;
      // Limit writes to admins (custom claims) or via server/admin SDK.
      allow write: if request.auth != null && request.auth.token.admin == true;
    }

    // Optional: user-owned documents metadata if you store file metadata in Firestore
    match /users/{uid}/documents/{docId} {
      allow read: if isOwner(uid);
      allow create: if isOwner(uid)
        && request.resource.data.ownerUid == request.auth.uid
        && request.resource.data.title is string
        && request.resource.data.storagePath is string;
      allow update, delete: if isOwnerOnExisting();
    }
  }
}
